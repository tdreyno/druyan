import flatten from "lodash.flatten";
import { Action, enter, isAction } from "./action";
import { Context } from "./context";
import { execute, runEffects } from "./core";
import { Effect, isEffect } from "./effect";
import { StateDidNotRespondToAction } from "./errors";
import { EventualAction, isEventualAction } from "./eventualAction";
import { BoundStateFn, isStateTransition, StateTransition } from "./state";

interface EventualActionsByState {
  [key: string]: Array<EventualAction<any, any>>;
}

type Unsubscriber = () => void;

interface UnSubOnExit {
  [key: string]: Unsubscriber[];
}

type ContextChangeSubscriber = (context: Context) => void;

interface RunReturn {
  context: Context;
  nextFramePromise?: Promise<RunReturn | undefined>;
}

function runNext<T>(run: () => Promise<T>): Promise<T> {
  return new Promise<T>(async resolve => {
    // tslint:disable-next-line: no-typeof-undefined
    if (typeof requestAnimationFrame !== "undefined") {
      requestAnimationFrame(async () => resolve(await run()));
    } else {
      setTimeout(async () => resolve(await run()), 10);
    }
  });
}

export class Runtime {
  static create(context: Context, fallback?: BoundStateFn<any, any, any>) {
    return new Runtime(context, fallback);
  }

  private unsubOnExit: UnSubOnExit = {};
  private contextChangeSubscribers: ContextChangeSubscriber[] = [];

  constructor(
    public context: Context,
    public fallback?: BoundStateFn<any, any, any>,
  ) {
    this.run = this.run.bind(this);
    this.runNextFrame = this.runNextFrame.bind(this);
  }

  onContextChange(fn: ContextChangeSubscriber) {
    this.contextChangeSubscribers.push(fn);

    return () => {
      this.contextChangeSubscribers = this.contextChangeSubscribers.filter(
        sub => sub !== fn,
      );
    };
  }

  disconnect() {
    this.contextChangeSubscribers = [];
  }

  currentState() {
    return this.context.currentState;
  }

  currentHistory() {
    return this.context.history;
  }

  // tslint:disable-next-line:max-func-body-length
  async run(action: Action<any>): Promise<RunReturn> {
    // Make sure we're in a valid state.
    this.validateCurrentState();

    // Run the action.
    const effects = await this.executeAction(action);

    return this.processEffects(effects);
  }

  async processEffects(effects: Effect[]): Promise<RunReturn> {
    if (effects.length <= 0) {
      return {
        context: this.context,
      };
    }

    // Run the resulting effects.
    const results = await runEffects(this.context, effects);

    // Schedule future actions.
    const nextFramePromise = this.scheduleWaitingForNextFrame(effects, results);

    // Find global eventual actions and ones generated by the final
    // state in the transition.
    const eventualActionsByState = this.collectionEventualActions(effects);

    // Subscribe to eventual actions
    this.unsubOnExit = this.subscribeToEventualActions(eventualActionsByState);

    // Notify subscribers
    this.contextChangeSubscribers.forEach(sub => sub(this.context));

    return {
      context: this.context,
      nextFramePromise,
    };
  }

  private async runNextFrame(
    action: Action<any> | undefined,
    transition: StateTransition<any, any, any> | undefined,
    effects: Effect[],
  ): Promise<RunReturn> {
    if (transition) {
      // add to history, run enter
      this.context.history.push(transition);

      return runNext(() => this.run(enter()));
    }

    if (action) {
      return runNext(() => this.run(action));
    }

    return this.processEffects(effects);
  }

  private validateCurrentState() {
    const runCurrentState = this.currentState();

    if (!runCurrentState) {
      throw new Error(
        `Druyan could not find current state to run action on. History: ${JSON.stringify(
          this.currentHistory()

            .map(({ name }) => name)
            .join(" -> "),
        )}`,
      );
    }
  }

  private async executeAction(action: Action<any>): Promise<Effect[]> {
    let effects: Effect[] = [];

    try {
      effects = await execute(action, this.context);
    } catch (e) {
      // Handle known error types.
      if (e instanceof StateDidNotRespondToAction) {
        // It's okay to not care about rAF
        if (e.action.type === "OnFrame") {
          return effects;
        }

        if (this.fallback) {
          const fallbackState = this.fallback(this.currentState);

          try {
            effects = await execute(action, this.context, fallbackState);
          } catch (e) {
            // Handle known error types.
            if (e instanceof StateDidNotRespondToAction) {
              // tslint:disable-next-line:no-console
              console.warn(
                `${e.toString()}. Fallback state "${
                  this.fallback.name
                }" also failed to handle event.`,
              );

              effects = [];
            }
          }
        } else {
          // tslint:disable-next-line:no-console
          console.warn(e.toString());

          effects = [];
        }
      } else {
        // Otherwise rethrow
        throw e;
      }
    }

    return effects;
  }

  private async scheduleWaitingForNextFrame(effects: Effect[], results: any[]) {
    const flatResult = flatten(results);
    const resultActions = flatResult.filter(isAction);
    const nextEffects = flatResult.filter(isEffect);
    const nextTransitions = flatResult.filter(isStateTransition);

    const effectActions = effects
      .filter(e => e.label === "runNextAction")
      .map(e => e.data as Action<any>);

    const nextActions = [...effectActions, ...resultActions];

    if (nextActions.length + nextTransitions.length > 1) {
      throw new Error("Cannot run more than one `runNextAction`");
    }

    // Run a single "next action" in one rAF cycle.
    return this.runNextFrame(nextActions[0], nextTransitions[0], nextEffects);
  }

  private collectionEventualActions(effects: Effect[]): EventualActionsByState {
    return effects.reduce(
      (sum, effect) => {
        // Store eventual actions by state name.
        if (isEventualAction(effect.data)) {
          sum[effect.data.createdInState!.name] =
            sum[effect.data.createdInState!.name] || [];
          sum[effect.data.createdInState!.name].push(effect.data);

          return sum;
        }

        if (effect.label === "exited") {
          // If non-global eventual actions are exitted in the same
          // transition, clean them up and never subscribe.
          if (sum[effect.data.name]) {
            sum[effect.data.name] = sum[effect.data.name].filter(
              e => e.doNotUnsubscribeOnExit,
            );
          }

          // Unsub those who care about exiting this state.
          if (this.unsubOnExit[effect.data.name]) {
            this.unsubOnExit[effect.data.name].forEach(unsub => unsub());
            delete this.unsubOnExit[effect.data.name];
          }
        }

        return sum;
      },
      {} as EventualActionsByState,
    );
  }

  private subscribeToEventualActions(
    eventualActionsByState: EventualActionsByState,
  ): UnSubOnExit {
    return Object.keys(eventualActionsByState).reduce((sum, stateName) => {
      const eventualActions = eventualActionsByState[stateName];

      for (const eventualAction of eventualActions) {
        const unsubscribe = eventualAction.subscribe(this.run);

        // Make a list of automatic unsubscribes
        if (!eventualAction.doNotUnsubscribeOnExit) {
          sum[stateName] = sum[stateName] || [];
          sum[stateName].push(unsubscribe);
        }
      }

      return sum;
    }, this.unsubOnExit);
  }
}

import { Action, isAction } from "./action";
import { Context } from "./context";
import { execute, runEffects } from "./core";
import { Effect } from "./effect";
import { StateDidNotRespondToAction } from "./errors";
import { EventualAction, isEventualAction } from "./eventualAction";
import { StateTransition } from "./state";

interface EventualActionsByState {
  [key: string]: Array<EventualAction<any, any>>;
}

type Unsubscriber = () => void;

interface UnSubOnExit {
  [key: string]: Unsubscriber[];
}

type ContextChangeSubscriber = (context: Context) => void;

interface RunReturn {
  context: Context;
  nextFramePromise?: Promise<RunReturn | undefined>;
}

export class Runtime {
  static create(
    context: Context,
    fallbackState?: StateTransition<any, any, any>,
  ) {
    return new Runtime(context, fallbackState);
  }

  private unsubOnExit: UnSubOnExit = {};
  private contextChangeSubscribers: ContextChangeSubscriber[] = [];

  constructor(
    public context: Context,
    public fallbackState?: StateTransition<any, any, any>,
  ) {
    this.run = this.run.bind(this);
    this.runNextFrame = this.runNextFrame.bind(this);
  }

  onContextChange(fn: ContextChangeSubscriber) {
    this.contextChangeSubscribers.push(fn);

    return () => {
      this.contextChangeSubscribers = this.contextChangeSubscribers.filter(
        sub => sub !== fn,
      );
    };
  }

  disconnect() {
    this.contextChangeSubscribers = [];
  }

  currentState() {
    return this.context.currentState;
  }

  currentHistory() {
    return this.context.history;
  }

  // tslint:disable-next-line:max-func-body-length
  async run(action: Action<any>): Promise<RunReturn> {
    // Make sure we're in a valid state.
    this.validateCurrentState();

    // Run the action.
    const effects = await this.executeAction(action);

    // Run the resulting effects.
    const futureActions = (await runEffects(this.context, effects)).filter(
      isAction,
    );

    // Schedule future actions.
    const nextFramePromise = this.scheduleActionsWaitingForNextFrame(
      effects,
      futureActions,
    );

    // Find global eventual actions and ones generated by the final
    // state in the transition.
    const eventualActionsByState = this.collectionEventualActions(effects);

    // Subscribe to eventual actions
    this.unsubOnExit = this.subscribeToEventualActions(eventualActionsByState);

    // Notify subscribers
    this.contextChangeSubscribers.forEach(sub => sub(this.context));

    return {
      context: this.context,
      nextFramePromise,
    };
  }

  private runNextFrame(a: Action<any>): Promise<RunReturn> {
    return new Promise(resolve => {
      // tslint:disable-next-line: no-typeof-undefined
      if (typeof requestAnimationFrame !== "undefined") {
        requestAnimationFrame(async () => resolve(await this.run(a)));
      } else {
        setTimeout(async () => resolve(await this.run(a)), 10);
      }
    });
  }

  private validateCurrentState() {
    const runCurrentState = this.currentState();

    if (!runCurrentState) {
      throw new Error(
        `Druyan could not find current state to run action on. History: ${JSON.stringify(
          this.currentHistory()

            .map(({ name }) => name)
            .join(" -> "),
        )}`,
      );
    }
  }

  private async executeAction(action: Action<any>): Promise<Effect[]> {
    let effects: Effect[] = [];

    try {
      effects = await execute(action, this.context);
    } catch (e) {
      // Handle known error types.
      if (e instanceof StateDidNotRespondToAction) {
        // It's okay to not care about rAF
        if (e.action.type === "OnFrame") {
          return effects;
        }

        if (this.fallbackState) {
          try {
            effects = await execute(action, this.context, this.fallbackState);
          } catch (e) {
            // Handle known error types.
            if (e instanceof StateDidNotRespondToAction) {
              // tslint:disable-next-line:no-console
              console.warn(
                `${e.toString()}. Fallback state "${
                  this.fallbackState.name
                }" also failed to handle event.`,
              );

              effects = [];
            }
          }
        } else {
          // tslint:disable-next-line:no-console
          console.warn(e.toString());

          effects = [];
        }
      } else {
        // Otherwise rethrow
        throw e;
      }
    }

    return effects;
  }

  private async scheduleActionsWaitingForNextFrame(
    effects: Effect[],
    futureActions: Array<Action<any>>,
  ) {
    const runNextActions: Array<Action<any>> = effects
      .filter(e => e.label === "runNextAction")
      .map(e => e.data as Action<any>)
      .concat(futureActions);

    if (runNextActions.length > 0) {
      if (runNextActions.length > 1) {
        throw new Error("Cannot run more than one `runNextAction`");
      }

      // Run a single "next action" in one rAF cycle.
      return this.runNextFrame(runNextActions[0]);
    }
  }

  private collectionEventualActions(effects: Effect[]): EventualActionsByState {
    return effects.reduce(
      (sum, effect) => {
        // Store eventual actions by state name.
        if (isEventualAction(effect.data)) {
          sum[effect.data.createdInState!.name] =
            sum[effect.data.createdInState!.name] || [];
          sum[effect.data.createdInState!.name].push(effect.data);

          return sum;
        }

        if (effect.label === "exited") {
          // If non-global eventual actions are exitted in the same
          // transition, clean them up and never subscribe.
          if (sum[effect.data.name]) {
            sum[effect.data.name] = sum[effect.data.name].filter(
              e => e.doNotUnsubscribeOnExit,
            );
          }

          // Unsub those who care about exiting this state.
          if (this.unsubOnExit[effect.data.name]) {
            this.unsubOnExit[effect.data.name].forEach(unsub => unsub());
            delete this.unsubOnExit[effect.data.name];
          }
        }

        return sum;
      },
      {} as EventualActionsByState,
    );
  }

  private subscribeToEventualActions(
    eventualActionsByState: EventualActionsByState,
  ): UnSubOnExit {
    return Object.keys(eventualActionsByState).reduce((sum, stateName) => {
      const eventualActions = eventualActionsByState[stateName];

      for (const eventualAction of eventualActions) {
        const unsubscribe = eventualAction.subscribe(this.run);

        // Make a list of automatic unsubscribes
        if (!eventualAction.doNotUnsubscribeOnExit) {
          sum[stateName] = sum[stateName] || [];
          sum[stateName].push(unsubscribe);
        }
      }

      return sum;
    }, this.unsubOnExit);
  }
}
